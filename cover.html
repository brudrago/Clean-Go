
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>http: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/brudrago/clean-go/adapter/http/main.go (0.0%)</option>
				
				<option value="file1">github.com/brudrago/clean-go/adapter/http/productservice/create.go (0.0%)</option>
				
				<option value="file2">github.com/brudrago/clean-go/adapter/http/productservice/fetch.go (0.0%)</option>
				
				<option value="file3">github.com/brudrago/clean-go/adapter/http/productservice/new.go (0.0%)</option>
				
				<option value="file4">github.com/brudrago/clean-go/adapter/postgres/connector.go (0.0%)</option>
				
				<option value="file5">github.com/brudrago/clean-go/adapter/postgres/productRepository/create.go (0.0%)</option>
				
				<option value="file6">github.com/brudrago/clean-go/adapter/postgres/productRepository/fetch.go (0.0%)</option>
				
				<option value="file7">github.com/brudrago/clean-go/adapter/postgres/productRepository/new.go (0.0%)</option>
				
				<option value="file8">github.com/brudrago/clean-go/core/domain/usecase/productusecase/create.go (0.0%)</option>
				
				<option value="file9">github.com/brudrago/clean-go/core/domain/usecase/productusecase/fetch.go (0.0%)</option>
				
				<option value="file10">github.com/brudrago/clean-go/core/domain/usecase/productusecase/new.go (0.0%)</option>
				
				<option value="file11">github.com/brudrago/clean-go/core/dto/pagination.go (100.0%)</option>
				
				<option value="file12">github.com/brudrago/clean-go/core/dto/product.go (0.0%)</option>
				
				<option value="file13">github.com/brudrago/clean-go/di/product.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "context"
        "fmt"
        "log"
        "net/http"

        "github.com/brudrago/clean-go/adapter/postgres"
        "github.com/brudrago/clean-go/di"
        "github.com/gorilla/mux"
        "github.com/spf13/viper"
)

func init() <span class="cov0" title="0">{
        viper.SetConfigFile(`config.json`)
        err := viper.ReadInConfig()
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
}

func main() <span class="cov0" title="0">{
        ctx := context.Background()
        conn := postgres.GetConnection(ctx)
        defer conn.Close()

        postgres.RunMigrations()
        productService := di.ConfigProductDI(conn)

        router := mux.NewRouter()
        router.Handle("/product", http.HandlerFunc(productService.Create)).Methods("POST")
        router.Handle("/product", http.HandlerFunc(productService.Fetch)).Queries(
                "page", "{page}",
                "itemsPerPage", "{itemsPerPage}",
                "descending", "{descending}",
                "sort", "{sort}",
                "search", "{search}",
        ).Methods("GET")

        port := viper.GetString("server.port")
        log.Printf("LISTEN ON PORT: %v", port)
        http.ListenAndServe(fmt.Sprintf(":%v", port), router)
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package productService

import (
        "encoding/json"
        "net/http"

        "github.com/brudrago/clean-go/core/dto"
)

func (service service) Create(response http.ResponseWriter, request *http.Request) <span class="cov0" title="0">{
        productRequest, err := dto.FromJSONCreateProductRequest(request.Body)
        if err != nil </span><span class="cov0" title="0">{
                response.WriteHeader(500)
                response.Write([]byte(err.Error()))
                return
        }</span>

        <span class="cov0" title="0">product, err := service.useCase.Create(productRequest)
        if err != nil </span><span class="cov0" title="0">{
                response.WriteHeader(500)
                response.Write([]byte(err.Error()))
                return
        }</span>

        <span class="cov0" title="0">json.NewEncoder(response).Encode(product)</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package productService

import (
        "encoding/json"
        "net/http"

        "github.com/brudrago/clean-go/core/dto"
)

func (service service) Fetch(response http.ResponseWriter, request *http.Request) <span class="cov0" title="0">{
        paginationRequest, err := dto.FromValuePaginationRequestParams(request)
        if err != nil </span><span class="cov0" title="0">{
                response.WriteHeader(500)
                response.Write([]byte(err.Error()))
                return
        }</span>

        <span class="cov0" title="0">products, err := service.useCase.Fetch(paginationRequest)
        if err != nil </span><span class="cov0" title="0">{
                response.WriteHeader(500)
                response.Write([]byte(err.Error()))
                return
        }</span>

        <span class="cov0" title="0">json.NewEncoder(response).Encode(products)</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package productService

import (
        "github.com/brudrago/clean-go/core/domain"
)

type service struct {
        useCase domain.ProductUseCase
}

func New(useCase domain.ProductUseCase) domain.ProductService <span class="cov0" title="0">{
        return &amp;service{
                useCase: useCase,
        }
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package postgres

import (
        "context"
        "fmt"
        "log"
        "os"

        "github.com/golang-migrate/migrate/v4"
        "github.com/jackc/pgconn"
        "github.com/jackc/pgx/v4"
        "github.com/jackc/pgx/v4/pgxpool"
        "github.com/spf13/viper"

        _ "github.com/golang-migrate/migrate/v4/database/pgx" //driver pgx used to run migrations
        _ "github.com/golang-migrate/migrate/v4/source/file"
)

// PoolInterface is an wraping to PgxPool to create test mocks
type PoolInterface interface {
        Close()
        Exec(ctx context.Context, sql string, arguments ...interface{}) (pgconn.CommandTag, error)
        Query(ctx context.Context, sql string, args ...interface{}) (pgx.Rows, error)
        QueryRow(ctx context.Context, sql string, args ...interface{}) pgx.Row
        QueryFunc(
                ctx context.Context,
                sql string,
                args []interface{},
                scans []interface{},
                f func(pgx.QueryFuncRow) error,
        ) (pgconn.CommandTag, error)
        SendBatch(ctx context.Context, b *pgx.Batch) pgx.BatchResults
        Begin(ctx context.Context) (pgx.Tx, error)
        BeginFunc(ctx context.Context, f func(pgx.Tx) error) error
        BeginTxFunc(ctx context.Context, txOptions pgx.TxOptions, f func(pgx.Tx) error) error
}

// GetConnection return connection pool from postgres drive PGX
func GetConnection(context context.Context) *pgxpool.Pool <span class="cov0" title="0">{
        databaseURL := viper.GetString("database.url")

        conn, err := pgxpool.Connect(context, "postgres"+databaseURL)

        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Unable to connect to database: %v\n", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">return conn</span>
}

// RunMigrations run scripts on path database/migrations
func RunMigrations() <span class="cov0" title="0">{
        databaseURL := viper.GetString("database.url")
        m, err := migrate.New("file://database/migrations", "pgx"+databaseURL)
        if err != nil </span><span class="cov0" title="0">{
                log.Println(err)
        }</span>

        <span class="cov0" title="0">if err := m.Up(); err != nil </span><span class="cov0" title="0">{
                log.Println(err)
        }</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package productRepository

import (
        "context"

        "github.com/brudrago/clean-go/core/domain"
        "github.com/brudrago/clean-go/core/dto"
)

func (repo repository) Create(productRequest *dto.CreateProductRequest) (*domain.Product, error) <span class="cov0" title="0">{
        ctx := context.Background()
        product := &amp;domain.Product{}

        err := repo.db.QueryRow(
                ctx,
                "INSERT INTO product (name, price, description) VALUES ($1, $2, $3) returning *",
                productRequest.Name,
                productRequest.Price,
                productRequest.Description,
        ).Scan(
                &amp;product.ID,
                &amp;product.Name,
                &amp;product.Price,
                &amp;product.Description,
        )

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return product, nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package productRepository

import (
        "context"

        "github.com/booscaaa/go-paginate/v3/paginate"
        "github.com/brudrago/clean-go/core/domain"
        "github.com/brudrago/clean-go/core/dto"
)

func (repo repository) Fetch(pagination *dto.PaginationRequestParams) (*domain.Pagination[[]domain.Product], error) <span class="cov0" title="0">{
        ctx := context.Background()
        products := []domain.Product{}
        var total int32

        // Builder base
        builder := paginate.NewBuilder().
                Table("product p").
                Model(&amp;domain.Product{}).
                Page(int(pagination.Page)).
                Limit(int(pagination.ItemsPerPage))

        // Busca (search)
        if pagination.Search != "" </span><span class="cov0" title="0">{
                builder = builder.Search(pagination.Search, "name", "description")
        }</span>

        // Sort (primeiro campo da lista)
        <span class="cov0" title="0">if len(pagination.Sort) &gt; 0 </span><span class="cov0" title="0">{
                sortField := pagination.Sort[0]

                // Se houver qualquer coisa em Descending, vamos considerar que Ã© descendente
                isDescending := len(pagination.Descending) &gt; 0

                if isDescending </span><span class="cov0" title="0">{
                        builder = builder.OrderByDesc(sortField)
                }</span> else<span class="cov0" title="0"> {
                        builder = builder.OrderBy(sortField)
                }</span>
        }

        // SQL da listagem
        <span class="cov0" title="0">query, args, err := builder.BuildSQL()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // SQL do COUNT
        <span class="cov0" title="0">countQuery, countArgs, err := builder.BuildCountSQL()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Busca paginada
        <span class="cov0" title="0">rows, err := repo.db.Query(ctx, query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        for rows.Next() </span><span class="cov0" title="0">{
                product := domain.Product{}
                if err := rows.Scan(
                        &amp;product.ID,
                        &amp;product.Name,
                        &amp;product.Price,
                        &amp;product.Description,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">products = append(products, product)</span>
        }

        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // COUNT total
        <span class="cov0" title="0">if err := repo.db.QueryRow(ctx, countQuery, countArgs...).Scan(&amp;total); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">paginationResult := &amp;domain.Pagination[[]domain.Product]{
                Items: products,
                Total: total,
        }

        return paginationResult, nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package productRepository

import (
        "github.com/brudrago/clean-go/adapter/postgres"
        "github.com/brudrago/clean-go/core/domain"
)

type repository struct {
        db postgres.PoolInterface
}

func New(db postgres.PoolInterface) domain.ProductRepository <span class="cov0" title="0">{
        return &amp;repository{
                db: db,
        }
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package productUseCase

import (
        "github.com/brudrago/clean-go/core/domain"
        "github.com/brudrago/clean-go/core/dto"
)

func (usecase usecase) Create(productRequest *dto.CreateProductRequest) (*domain.Product, error) <span class="cov0" title="0">{
        product, err := usecase.repo.Create(productRequest)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return product, nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package productUseCase

import (
        "github.com/brudrago/clean-go/core/domain"
        "github.com/brudrago/clean-go/core/dto"
)

func (usecase usecase) Fetch(paginationRequest *dto.PaginationRequestParams) (*domain.Pagination[[]domain.Product], error) <span class="cov0" title="0">{
        products, err := usecase.repo.Fetch(paginationRequest)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return products, nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package productUseCase

import (
        "github.com/brudrago/clean-go/core/domain"
)

type usecase struct {
        repo domain.ProductRepository
}

func New(repo domain.ProductRepository) domain.ProductUseCase <span class="cov0" title="0">{
        return &amp;usecase{
                repo: repo,
        }
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package dto

import (
        "net/http"
        "strconv"
        "strings"
)

// PaginationRequestParams is an representation query string params to filter and paginate products
type PaginationRequestParams struct {
        Page         int      `json:"page"`
        Search       string   `json:"search"`
        Descending   []string `json:"descending"`
        ItemsPerPage int      `json:"itemsPerPage"`
        Sort         []string `json:"sort"`
}

// FromValuePaginationRequestParams converts query string params to a PaginationRequestParams struct
func FromValuePaginationRequestParams(request *http.Request) (*PaginationRequestParams, error) <span class="cov8" title="1">{
        page, _ := strconv.Atoi(request.FormValue("page"))
        itemsPerPage, _ := strconv.Atoi(request.FormValue("itemsPerPage"))

        paginationRequestParams := PaginationRequestParams{
                Search:       request.FormValue("search"),
                Descending:   strings.Split(request.FormValue("descending"), ","),
                Sort:         strings.Split(request.FormValue("sort"), ","),
                Page:         page,
                ItemsPerPage: itemsPerPage,
        }

        return &amp;paginationRequestParams, nil
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package dto

import (
        "encoding/json"
        "io"
)

type CreateProductRequest struct {
        Name        string  `json:"name"`
        Price       float64 `json:"price"`
        Description string  `json:"description"`
}

func FromJSONCreateProductRequest(body io.Reader) (*CreateProductRequest, error) <span class="cov0" title="0">{
        createProductRequest := CreateProductRequest{}

        if err := json.NewDecoder(body).Decode(&amp;createProductRequest); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;createProductRequest, nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package di

import (
        productService "github.com/brudrago/clean-go/adapter/http/productservice"
        "github.com/brudrago/clean-go/adapter/postgres"
        "github.com/brudrago/clean-go/adapter/postgres/productRepository"
        "github.com/brudrago/clean-go/core/domain"
        productUseCase "github.com/brudrago/clean-go/core/domain/usecase/productusecase"
)

// ConfigProductDI return a ProductService abstraction with dependency injection configuration
func ConfigProductDI(conn postgres.PoolInterface) domain.ProductService <span class="cov0" title="0">{
        productRepository := productRepository.New(conn)
        productUseCase := productUseCase.New(productRepository)
        productService := productService.New(productUseCase)

        return productService
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
